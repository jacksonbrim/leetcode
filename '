pub fn my_atoi(s: String) -> i32 {
    let mut intermediate = String::new();
    let mut last_char = ' ';
    for ch in s.chars() {
        if ch.is_digit(10) || ch == '-' || ch == '+' {
            if intermediate.is_empty() && last_char == '-' {
                intermediate.push(last_char);
            }
            intermediate.push(ch);
        }
        if intermediate.is_empty() {
            last_char = ch;
        }
    }
    intermediate.parse::<i32>().unwrap()
}

pub fn main() {}

#[cfg(test)]
mod tests {
    use crate::string_to_int::*;
    #[test]
    fn basic_positive_success() {
        let s = "42".to_string();
        let output = 42;
        let res = my_atoi(s);
        assert_eq!(res, output);
    }
    #[test]
    fn negative_leading_whitespace_success() {
        let s = "    -42".to_string();
        let output = -42;
        let res = my_atoi(s);
        assert_eq!(res, output);
    }
    #[test]
    fn negative_leading_chars_success() {
        let s = "____-42".to_string();
        let output = -42;
        let res = my_atoi(s);
        assert_eq!(res, output);
    }
    #[test]
    fn ending_with_words_success() {
        let s = "4193 with words".to_string();
        let output = 4193;
        let res = my_atoi(s);
        assert_eq!(res, output);
    }
    #[test]
    fn starting_with_words_success() {
        let s = "words and 987".to_string();
        let output = 987;
        let res = my_atoi(s);
        assert_eq!(res, output);
    }
}
